<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>매크로 방지 이미지 생성기</title>

  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 24px;
      background: #f5f5f5;
    }

    .container {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
    }

    h1 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 22px;
    }

    .field-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    textarea,
    input[type="number"],
    input[type="text"],
    input[type="file"] {
      width: 100%;
      padding: 8px 10px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid #cccccc;
      outline: none;
    }

    textarea:focus,
    input[type="number"]:focus,
    input[type="text"]:focus {
      border-color: #1e88e5;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
      max-height: 200px;
    }

    .size-row {
      display: flex;
      gap: 8px;
    }

    .size-row .field-group {
      flex: 1;
      margin-bottom: 0;
    }

    button {
      padding: 8px 14px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      background: #1e88e5;
      color: #ffffff;
      cursor: pointer;
      font-weight: 600;
    }

    button.secondary {
      background: #666666;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    #status {
      margin-top: 8px;
      font-size: 13px;
      color: #555555;
      min-height: 18px;
    }

    #result {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
    }

    #preview-wrapper {
      display: inline-block;
      padding: 8px;
      background: #fafafa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      max-width: 100%;
    }

    #preview {
      max-width: 100%;
      height: auto;
      display: block;
    }

    #downloadLink {
      display: inline-block;
      margin-top: 12px;
      font-size: 14px;
      text-decoration: none;
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid #1e88e5;
      color: #1e88e5;
    }

    .hidden {
      display: none;
    }

    /* 텍스트 커스텀 영역 */
    #fontControls {
      margin-top: 8px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      max-height: 260px;
      overflow-y: auto;
      font-size: 13px;
    }

    #fontControls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
      flex-wrap: wrap;
    }

    #fontControls-header span {
      font-weight: 600;
    }

    #fontControls-header .global-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    #fontControls-header label {
      margin-bottom: 0;
      font-weight: 500;
      font-size: 12px;
    }

    #fontControls-header select,
    #fontControls-header input[type="color"],
    #fontControls-header input[type="number"] {
      padding: 3px 4px;
      font-size: 12px;
    }

    #fontControls-header input[type="number"] {
      width: 70px;
    }

    .char-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .char-item {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 6px;
      border-radius: 6px;
      background: #ffffff;
      border: 1px solid #e0e0e0;
    }

    .char-symbol {
      min-width: 20px;
      text-align: center;
      font-weight: 600;
    }

    .char-symbol.is-space {
      color: #999999;
    }

    .char-item select.font-select {
      padding: 3px 4px;
      font-size: 11px;
      max-width: 150px;
    }

    .char-item input.color-input {
      width: 28px;
      height: 22px;
      padding: 0;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    .char-item input.size-input {
      width: 55px;
      padding: 2px 4px;
      font-size: 11px;
    }

    .char-item input.rotate-input {
      width: 55px;
      padding: 2px 4px;
      font-size: 11px;
    }

    /* 배경 이미지 선택 캔버스 */
    #sourceCanvasWrapper {
      margin-top: 8px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
    }

    #sourceCanvas {
      max-width: 100%;
      background: #000000;
      cursor: crosshair;
    }

    #selectionInfo {
      margin-top: 4px;
      font-size: 12px;
      color: #555555;
    }

    #canvas {
      display: none;
    }

    .bg-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
    }

    .bg-input-row input[type="file"] {
      flex: 1;
    }

    .anti-macro-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 6px;
      font-size: 12px;
    }

    .pattern-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
      font-weight: 500;
    }

    .pattern-row input[type="checkbox"] {
      width: auto;
    }

    .pattern-row span.label-kind {
      min-width: 30px;
    }

    .pattern-row input[type="number"] {
      width: 70px;
      padding: 3px 4px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>매크로 방지 이미지 생성기</h1>

    <form id="imageForm">
      <div class="field-group">
        <label for="prompt">이미지에 넣을 텍스트</label>
        <textarea
          id="prompt"
          placeholder="이미지에 들어갈 텍스트를 입력해주세요."
        ></textarea>
        <div id="fontControls" class="hidden">
          <div id="fontControls-header">
            <span>텍스트 커스텀</span>
            <div class="global-controls">
              <label>
                전체 폰트:
                <select id="allFontSelect"></select>
              </label>
              <label>
                전체 색상:
                <input type="color" id="allColorInput" value="#ffffff" />
              </label>
              <label>
                전체 크기(px):
                <input type="number" id="allSizeInput" min="8" max="300" value="20" />
              </label>
              <label>
                전체 회전(도):
                <input type="number" id="globalRotateInput" min="-90" max="90" value="0" />
              </label>
              <label>
                랜덤 왜곡 강도:
                <input type="number" id="distortInput" min="0" max="50" value="0" />
              </label>
            </div>
          </div>
          <div class="char-list" id="charList"></div>
        </div>
      </div>

      <div class="field-group">
        <label for="bgImageInput">배경 이미지</label>
        <div class="bg-input-row">
          <input type="file" id="bgImageInput" accept="image/*" />
          <button type="button" id="randomBgBtn" class="secondary">
            랜덤 배경 (Lorem Picsum)
          </button>
        </div>
        <div style="font-size:12px; color:#777; margin-top:4px;">
          랜덤 배경 버튼: <code>https://picsum.photos</code>에서 현재 설정된 최종 가로·세로 크기에 맞춰 랜덤 이미지를 가져옵니다.
        </div>
        <div id="sourceCanvasWrapper" class="hidden">
          <canvas id="sourceCanvas"></canvas>
          <div id="selectionInfo">
            마우스로 드래그해서 사용할 영역을 선택할 수 있습니다. 선택하지 않으면 전체 이미지가 사용됩니다.
          </div>
        </div>
      </div>

      <div class="size-row">
        <div class="field-group">
          <label for="width">최종 이미지 가로(px)</label>
          <input
            type="number"
            id="width"
            min="64"
            max="2048"
            value="222"
            required
          />
        </div>
        <div class="field-group">
          <label for="height">최종 이미지 세로(px)</label>
          <input
            type="number"
            id="height"
            min="64"
            max="2048"
            value="90"
            required
          />
        </div>
      </div>

      <div class="field-group">
        <label>패턴 복잡도</label>
        <div class="anti-macro-options">
          <div class="pattern-row">
            <input type="checkbox" id="lineEnabled" />
            <span class="label-kind">선</span>
            <span>개수</span>
            <input type="number" id="lineCountInput" min="1" max="100" value="5" />
            <span>굵기</span>
            <input type="number" id="lineWidthInput" min="1" max="20" value="2" />
          </div>
          <div class="pattern-row">
            <input type="checkbox" id="rectEnabled" />
            <span class="label-kind">면</span>
            <span>개수</span>
            <input type="number" id="rectCountInput" min="1" max="50" value="3" />
            <span>굵기</span>
            <input type="number" id="rectThicknessInput" min="1" max="20" value="5" />
          </div>
          <div class="pattern-row">
            <input type="checkbox" id="circleEnabled" />
            <span class="label-kind">원</span>
            <span>개수</span>
            <input type="number" id="circleCountInput" min="1" max="200" value="30" />
            <span>굵기</span>
            <input type="number" id="circleThicknessInput" min="1" max="20" value="5" />
          </div>
        </div>
        <div style="font-size:12px; color:#777; margin-top:4px;">
          선, 면, 원 중 필요한 패턴만 체크해서 사용하고 개수와 굵기를 조절해 복잡도를 설정할 수 있습니다.
        </div>
      </div>

      <div style="margin-top: 16px;">
        <button type="submit" id="generateBtn">이미지 생성</button>
      </div>

      <div id="status"></div>
    </form>

    <div id="result" class="hidden">
      <h2 style="font-size: 16px; margin: 0 0 12px;">생성된 이미지 미리보기</h2>
      <div id="preview-wrapper">
        <img id="preview" alt="생성된 이미지 미리보기" />
      </div>
      <div>
        <a id="downloadLink" href="#" download="text-image.bmp">BMP로 이미지 다운로드</a>
      </div>
    </div>

    <canvas id="canvas"></canvas>
  </div>

  <script>
    // 윈도우에서 자주 사용하는 폰트들
    const FONT_OPTIONS = [
      { value: "Malgun Gothic", label: "맑은 고딕 (Malgun Gothic)" },
      { value: "Gulim", label: "굴림 (Gulim)" },
      { value: "Dotum", label: "돋움 (Dotum)" },
      { value: "Batang", label: "바탕 (Batang)" },
      { value: "Arial", label: "Arial" },
      { value: "Times New Roman", label: "Times New Roman" },
      { value: "Consolas", label: "Consolas" }
    ];

    const DEFAULT_COLOR = "#ffffff";
    const DEFAULT_SIZE = 20;

    const form = document.getElementById("imageForm");
    const statusEl = document.getElementById("status");
    const preview = document.getElementById("preview");
    const result = document.getElementById("result");
    const downloadLink = document.getElementById("downloadLink");
    const generateBtn = document.getElementById("generateBtn");
    const promptInput = document.getElementById("prompt");

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const fontControls = document.getElementById("fontControls");
    const charList = document.getElementById("charList");
    const allFontSelect = document.getElementById("allFontSelect");
    const allColorInput = document.getElementById("allColorInput");
    const allSizeInput = document.getElementById("allSizeInput");
    const globalRotateInput = document.getElementById("globalRotateInput");
    const distortInput = document.getElementById("distortInput");

    const bgImageInput = document.getElementById("bgImageInput");
    const randomBgBtn = document.getElementById("randomBgBtn");
    const sourceCanvasWrapper = document.getElementById("sourceCanvasWrapper");
    const sourceCanvas = document.getElementById("sourceCanvas");
    const sourceCtx = sourceCanvas.getContext("2d");
    const selectionInfo = document.getElementById("selectionInfo");

    // 패턴 관련 요소
    const lineEnabledCheckbox = document.getElementById("lineEnabled");
    const rectEnabledCheckbox = document.getElementById("rectEnabled");
    const circleEnabledCheckbox = document.getElementById("circleEnabled");

    const lineCountInput = document.getElementById("lineCountInput");
    const rectCountInput = document.getElementById("rectCountInput");
    const circleCountInput = document.getElementById("circleCountInput");

    const lineWidthInput = document.getElementById("lineWidthInput");
    const rectThicknessInput = document.getElementById("rectThicknessInput");
    const circleThicknessInput = document.getElementById("circleThicknessInput");

    // 배경 이미지 상태
    let sourceImage = null;
    let sourceScale = 1;
    let selection = null;
    let isSelecting = false;
    let selStartX = 0;
    let selStartY = 0;

    function initFontSelectOptions(selectEl) {
      selectEl.innerHTML = "";
      FONT_OPTIONS.forEach((font, index) => {
        const option = document.createElement("option");
        option.value = font.value;
        option.textContent = font.label;
        if (index === 0) option.selected = true;
        selectEl.appendChild(option);
      });
    }
    initFontSelectOptions(allFontSelect);

    function updateFontControls(text) {
      charList.innerHTML = "";

      if (!text || text.length === 0) {
        fontControls.classList.add("hidden");
        return;
      }

      fontControls.classList.remove("hidden");

      const chars = Array.from(text);

      let globalDeg = parseFloat(globalRotateInput.value);
      if (!Number.isFinite(globalDeg)) globalDeg = 0;
      if (globalDeg < -90) globalDeg = -90;
      if (globalDeg > 90) globalDeg = 90;
      globalRotateInput.value = globalDeg.toString();

      chars.forEach((ch, index) => {
        const item = document.createElement("div");
        item.className = "char-item";
        item.dataset.index = index.toString();

        const span = document.createElement("span");
        span.className = "char-symbol";
        if (ch === " ") {
          span.textContent = "␣";
          span.classList.add("is-space");
        } else if (ch === "\n") {
          span.textContent = "↵";
          span.classList.add("is-space");
        } else {
          span.textContent = ch;
        }

        const fontSelect = document.createElement("select");
        fontSelect.className = "font-select";
        FONT_OPTIONS.forEach((font, i) => {
          const option = document.createElement("option");
          option.value = font.value;
          option.textContent = font.label;
          if (i === 0) option.selected = true;
          fontSelect.appendChild(option);
        });

        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.className = "color-input";
        colorInput.value = DEFAULT_COLOR;

        const sizeInput = document.createElement("input");
        sizeInput.type = "number";
        sizeInput.className = "size-input";
        sizeInput.min = "8";
        sizeInput.max = "300";
        sizeInput.value = DEFAULT_SIZE.toString();

        const rotateInput = document.createElement("input");
        rotateInput.type = "number";
        rotateInput.className = "rotate-input";
        rotateInput.min = "-180";
        rotateInput.max = "180";
        rotateInput.value = globalDeg.toString();
        rotateInput.title = "회전(도)";

        item.appendChild(span);
        item.appendChild(fontSelect);
        item.appendChild(colorInput);
        item.appendChild(sizeInput);
        item.appendChild(rotateInput);
        charList.appendChild(item);
      });
    }

    allFontSelect.addEventListener("change", () => {
      const value = allFontSelect.value;
      const selects = charList.querySelectorAll("select.font-select");
      selects.forEach((select) => {
        select.value = value;
      });
    });

    allColorInput.addEventListener("change", () => {
      const value = allColorInput.value;
      const colors = charList.querySelectorAll("input.color-input");
      colors.forEach((input) => {
        input.value = value;
      });
    });

    allSizeInput.addEventListener("change", () => {
      let value = parseInt(allSizeInput.value, 10);
      if (!Number.isFinite(value) || value < 8) value = 8;
      if (value > 300) value = 300;
      allSizeInput.value = value.toString();

      const sizes = charList.querySelectorAll("input.size-input");
      sizes.forEach((input) => {
        input.value = value.toString();
      });
    });

    globalRotateInput.addEventListener("change", () => {
      let value = parseFloat(globalRotateInput.value);
      if (!Number.isFinite(value)) value = 0;
      if (value < -90) value = -90;
      if (value > 90) value = 90;
      globalRotateInput.value = value.toString();

      const rotates = charList.querySelectorAll("input.rotate-input");
      rotates.forEach((input) => {
        input.value = value.toString();
      });
    });

    promptInput.addEventListener("input", () => {
      updateFontControls(promptInput.value);
    });

    // 랜덤 배경 (Lorem Picsum)
    randomBgBtn.addEventListener("click", () => {
      let width = parseInt(document.getElementById("width").value, 10);
      let height = parseInt(document.getElementById("height").value, 10);

      if (!Number.isFinite(width) || width < 64) width = 64;
      if (!Number.isFinite(height) || height < 64) height = 64;
      if (width > 2048) width = 2048;
      if (height > 2048) height = 2048;

      const url = `https://picsum.photos/${width}/${height}?random=${Date.now()}`;

      statusEl.textContent = "랜덤 배경 이미지를 불러오는 중입니다.";
      const img = new Image();
      img.crossOrigin = "anonymous";

      img.onload = () => {
        sourceImage = img;
        selection = null;
        drawSourceCanvas();
        statusEl.textContent = "랜덤 배경 이미지가 로드되었습니다. 필요하면 영역을 드래그해서 선택할 수 있습니다.";
      };

      img.onerror = () => {
        statusEl.textContent = "랜덤 배경 이미지를 불러오지 못했습니다.";
      };

      img.src = url;
    });

    // 색 관련 유틸
    function randomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return { r, g, b };
    }

    function colorToCss(c) {
      return `rgb(${c.r}, ${c.g}, ${c.b})`;
    }

    function colorToCssWithAlpha(c, alpha) {
      return `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha})`;
    }

    function drawRandomBackground(ctx, width, height) {
      const c1 = randomColor();
      const c2 = randomColor();
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, colorToCss(c1));
      gradient.addColorStop(1, colorToCss(c2));
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      const circleCount = 8 + Math.floor(Math.random() * 6);
      for (let i = 0; i < circleCount; i++) {
        const radius = Math.random() * (Math.min(width, height) / 3);
        const cx = Math.random() * width;
        const cy = Math.random() * height;
        const c = randomColor();
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = colorToCssWithAlpha(c, 0.3);
        ctx.fill();
      }

      const rectCount = 20;
      for (let i = 0; i < rectCount; i++) {
        const rw = 30 + Math.random() * (width / 4);
        const rh = 10 + Math.random() * (height / 6);
        const rx = Math.random() * width;
        const ry = Math.random() * height;
        const c = randomColor();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = colorToCss(c);
        ctx.fillRect(rx, ry, rw, rh);
        ctx.globalAlpha = 1;
      }
    }

    // 글자 스타일 매핑
    function getCharStyles(text) {
      const chars = Array.from(text);
      const styles = [];
      const defaultFont = FONT_OPTIONS[0].value;

      let globalRotateDeg = parseFloat(globalRotateInput.value);
      if (!Number.isFinite(globalRotateDeg)) globalRotateDeg = 0;
      if (globalRotateDeg < -90) globalRotateDeg = -90;
      if (globalRotateDeg > 90) globalRotateDeg = 90;
      globalRotateInput.value = globalRotateDeg.toString();

      let distort = parseFloat(distortInput.value);
      if (!Number.isFinite(distort) || distort < 0) distort = 0;
      if (distort > 50) distort = 50;
      distortInput.value = distort.toString();

      const baseAngleRad = (globalRotateDeg * Math.PI) / 180;

      const items = charList.querySelectorAll(".char-item");
      items.forEach((item) => {
        const idx = parseInt(item.dataset.index, 10);
        const fontSelect = item.querySelector("select.font-select");
        const colorInput = item.querySelector("input.color-input");
        const sizeInput = item.querySelector("input.size-input");
        const rotateInput = item.querySelector("input.rotate-input");

        let fontFamily = fontSelect ? fontSelect.value : defaultFont;
        let color = colorInput ? colorInput.value : DEFAULT_COLOR;
        let fontSize = sizeInput ? parseInt(sizeInput.value, 10) : DEFAULT_SIZE;

        if (!fontFamily) fontFamily = defaultFont;
        if (!color) color = DEFAULT_COLOR;
        if (!Number.isFinite(fontSize) || fontSize < 8) fontSize = 8;
        if (fontSize > 300) fontSize = 300;

        let charRotateDeg = rotateInput ? parseFloat(rotateInput.value) : 0;
        if (!Number.isFinite(charRotateDeg)) charRotateDeg = 0;
        if (charRotateDeg < -180) charRotateDeg = -180;
        if (charRotateDeg > 180) charRotateDeg = 180;
        if (rotateInput) {
          rotateInput.value = charRotateDeg.toString();
        }

        let jitterDeg = 0;
        let offsetX = 0;
        let offsetY = 0;
        if (distort > 0) {
          jitterDeg = (Math.random() - 0.5) * distort;
          offsetX = (Math.random() - 0.5) * distort;
          offsetY = (Math.random() - 0.5) * distort;
        }
        const totalDeg = globalRotateDeg + charRotateDeg + jitterDeg;
        const rotationRad = (totalDeg * Math.PI) / 180;

        styles[idx] = { fontFamily, fontSize, color, rotationRad, offsetX, offsetY };
      });

      for (let i = 0; i < chars.length; i++) {
        if (!styles[i]) {
          styles[i] = {
            fontFamily: defaultFont,
            fontSize: DEFAULT_SIZE,
            color: DEFAULT_COLOR,
            rotationRad: baseAngleRad,
            offsetX: 0,
            offsetY: 0
          };
        }
      }

      return styles;
    }

    function buildLineDataWithStyles(text, styles) {
      const lines = text.split("\n");
      const result = [];
      let globalIndex = 0;
      const defaultStyle = {
        fontFamily: FONT_OPTIONS[0].value,
        fontSize: DEFAULT_SIZE,
        color: DEFAULT_COLOR,
        rotationRad: 0,
        offsetX: 0,
        offsetY: 0
      };

      for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
        const lineText = lines[lineIdx];
        const chars = Array.from(lineText);
        const items = [];

        for (let i = 0; i < chars.length; i++) {
          const ch = chars[i];
          const style = styles[globalIndex] || defaultStyle;
          items.push({
            ch,
            fontFamily: style.fontFamily,
            fontSize: style.fontSize,
            color: style.color,
            rotationRad: style.rotationRad,
            offsetX: style.offsetX,
            offsetY: style.offsetY
          });
          globalIndex++;
        }

        if (lineIdx < lines.length - 1) {
          globalIndex++;
        }

        result.push(items);
      }

      return result;
    }

    function drawTextCharacters(ctx, width, height, text, styles) {
      if (!text || text.length === 0) return;

      const lineData = buildLineDataWithStyles(text, styles);

      const lineWidths = [];
      const lineHeights = [];
      const lineMaxFontSizes = [];
      let totalHeight = 0;

      lineData.forEach((items, idx) => {
        let lineWidth = 0;
        let maxFontSize = 0;

        items.forEach((item) => {
          const fontSize = item.fontSize;
          const fontFamily = item.fontFamily;
          ctx.font = `${fontSize}px "${fontFamily}", system-ui, sans-serif`;
          const metrics = ctx.measureText(item.ch);
          lineWidth += metrics.width;
          if (fontSize > maxFontSize) maxFontSize = fontSize;
        });

        const lineHeight = maxFontSize * 1.4;
        lineWidths[idx] = lineWidth;
        lineHeights[idx] = lineHeight;
        lineMaxFontSizes[idx] = maxFontSize;
        totalHeight += lineHeight;
      });

      let currentY = (height - totalHeight) / 2;
      ctx.textBaseline = "alphabetic";

      lineData.forEach((items, lineIdx) => {
        const lineWidth = lineWidths[lineIdx];
        const maxFontSize = lineMaxFontSizes[lineIdx];
        const lineHeight = lineHeights[lineIdx];

        const baselineY = currentY + maxFontSize;
        let x = (width - lineWidth) / 2;

        items.forEach((item) => {
          const fontSize = item.fontSize;
          const fontFamily = item.fontFamily;
          const color = item.color;

          ctx.font = `${fontSize}px "${fontFamily}", system-ui, sans-serif`;
          ctx.fillStyle = color;
          ctx.strokeStyle = "rgba(0, 0, 0, 0.85)";
          ctx.lineWidth = Math.max(fontSize / 12, 1);

          const metrics = ctx.measureText(item.ch);
          const charWidth = metrics.width;

          const cx = x + charWidth / 2 + (item.offsetX || 0);
          const cy = baselineY + (item.offsetY || 0);

          ctx.save();
          ctx.translate(cx, cy);
          if (item.rotationRad) ctx.rotate(item.rotationRad);
          ctx.strokeText(item.ch, -charWidth / 2, 0);
          ctx.fillText(item.ch, -charWidth / 2, 0);
          ctx.restore();

          x += charWidth;
        });

        currentY += lineHeight;
      });
    }

    // 패턴 그리기: 선 / 면 / 원
    function drawAntiMacroPattern(ctx, width, height) {
      const useLine = lineEnabledCheckbox.checked;
      const useRect = rectEnabledCheckbox.checked;
      const useCircle = circleEnabledCheckbox.checked;

      if (!useLine && !useRect && !useCircle) return;

      let lineCount = parseInt(lineCountInput.value, 10);
      let rectCount = parseInt(rectCountInput.value, 10);
      let circleCount = parseInt(circleCountInput.value, 10);

      let lineWidth = parseFloat(lineWidthInput.value);
      let rectThickness = parseFloat(rectThicknessInput.value);
      let circleThickness = parseFloat(circleThicknessInput.value);

      if (!Number.isFinite(lineCount) || lineCount < 1) lineCount = 1;
      if (lineCount > 100) lineCount = 100;
      lineCountInput.value = lineCount.toString();

      if (!Number.isFinite(rectCount) || rectCount < 1) rectCount = 1;
      if (rectCount > 50) rectCount = 50;
      rectCountInput.value = rectCount.toString();

      if (!Number.isFinite(circleCount) || circleCount < 1) circleCount = 1;
      if (circleCount > 200) circleCount = 200;
      circleCountInput.value = circleCount.toString();

      if (!Number.isFinite(lineWidth) || lineWidth < 1) lineWidth = 1;
      if (lineWidth > 20) lineWidth = 20;
      lineWidthInput.value = lineWidth.toString();

      if (!Number.isFinite(rectThickness) || rectThickness < 1) rectThickness = 1;
      if (rectThickness > 20) rectThickness = 20;
      rectThicknessInput.value = rectThickness.toString();

      if (!Number.isFinite(circleThickness) || circleThickness < 1) circleThickness = 1;
      if (circleThickness > 20) circleThickness = 20;
      circleThicknessInput.value = circleThickness.toString();

      ctx.save();

      // 원 패턴 (이전 점 패턴을 확대해서 사용)
      if (useCircle) {
        ctx.globalAlpha = 0.28;
        const baseRadius = Math.min(width, height) / 40;
        for (let i = 0; i < circleCount; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const radius =
            baseRadius * (0.4 + Math.random() * 0.6) * (circleThickness / 5);
          const c = randomColor();
          ctx.fillStyle = colorToCss(c);
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // 면 패턴 (반투명 직사각형)
      if (useRect) {
        const base = rectThickness / 10;
        for (let i = 0; i < rectCount; i++) {
          const c = randomColor();
          const maxRectW = width * 0.7 * base;
          const maxRectH = height * 0.7 * base;
          const wRect = (width / 8) + Math.random() * maxRectW;
          const hRect = (height / 8) + Math.random() * maxRectH;
          const xRect = Math.random() * (width - wRect);
          const yRect = Math.random() * (height - hRect);

          ctx.globalAlpha = 0.12 + Math.random() * 0.1;
          ctx.fillStyle = colorToCss(c);
          ctx.fillRect(xRect, yRect, wRect, hRect);
        }
      }

      // 선 패턴
      if (useLine) {
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = lineWidth;

        for (let i = 0; i < lineCount; i++) {
          const x1 = Math.random() * width;
          const y1 = Math.random() * height;
          const x2 = Math.random() * width;
          const y2 = Math.random() * height;

          const c = randomColor();
          ctx.strokeStyle = colorToCss(c);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    // BMP 변환
    function canvasToBMPBlob(canvas) {
      const w = canvas.width;
      const h = canvas.height;
      const ctxLocal = canvas.getContext("2d");
      const imageData = ctxLocal.getImageData(0, 0, w, h);
      const pixels = imageData.data;

      const rowSize = Math.floor((24 * w + 31) / 32) * 4;
      const imageSize = rowSize * h;
      const headerSize = 54;
      const fileSize = headerSize + imageSize;

      const buffer = new ArrayBuffer(fileSize);
      const dv = new DataView(buffer);

      dv.setUint8(0, 0x42);
      dv.setUint8(1, 0x4d);
      dv.setUint32(2, fileSize, true);
      dv.setUint32(6, 0, true);
      dv.setUint32(10, headerSize, true);

      dv.setUint32(14, 40, true);
      dv.setInt32(18, w, true);
      dv.setInt32(22, -h, true);
      dv.setUint16(26, 1, true);
      dv.setUint16(28, 24, true);
      dv.setUint32(30, 0, true);
      dv.setUint32(34, imageSize, true);
      dv.setInt32(38, 2835, true);
      dv.setInt32(42, 2835, true);
      dv.setUint32(46, 0, true);
      dv.setUint32(50, 0, true);

      let offset = headerSize;
      const padding = rowSize - w * 3;

      let i = 0;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const r = pixels[i];
          const g = pixels[i + 1];
          const b = pixels[i + 2];
          dv.setUint8(offset++, b);
          dv.setUint8(offset++, g);
          dv.setUint8(offset++, r);
          i += 4;
        }
        for (let p = 0; p < padding; p++) {
          dv.setUint8(offset++, 0);
        }
      }

      return new Blob([buffer], { type: "image/bmp" });
    }

    function drawSourceCanvas() {
      if (!sourceImage) {
        sourceCanvasWrapper.classList.add("hidden");
        return;
      }

      const maxPreviewWidth = 600;
      const maxPreviewHeight = 400;
      const iw = sourceImage.naturalWidth;
      const ih = sourceImage.naturalHeight;

      const scale = Math.min(maxPreviewWidth / iw, maxPreviewHeight / ih, 1);
      sourceScale = scale;

      const cw = Math.round(iw * scale);
      const ch = Math.round(ih * scale);

      sourceCanvas.width = cw;
      sourceCanvas.height = ch;
      sourceCanvasWrapper.classList.remove("hidden");

      sourceCtx.clearRect(0, 0, cw, ch);
      sourceCtx.drawImage(sourceImage, 0, 0, cw, ch);

      if (selection) {
        const { x, y, w, h } = selection;
        sourceCtx.save();
        sourceCtx.strokeStyle = "rgba(255, 255, 255, 0.9)";
        sourceCtx.lineWidth = 2;
        sourceCtx.strokeRect(x, y, w, h);
        sourceCtx.fillStyle = "rgba(0, 0, 0, 0.25)";
        sourceCtx.fillRect(x, y, w, h);
        sourceCtx.restore();
      }

      if (selection) {
        const sx = Math.round(selection.x / sourceScale);
        const sy = Math.round(selection.y / sourceScale);
        const sw = Math.round(selection.w / sourceScale);
        const sh = Math.round(selection.h / sourceScale);
        selectionInfo.textContent =
          `선택 영역: 원본 기준 x=${sx}, y=${sy}, w=${sw}, h=${sh}`;
      } else {
        selectionInfo.textContent =
          "마우스로 드래그해서 사용할 영역을 선택할 수 있습니다. 선택하지 않으면 전체 이미지가 사용됩니다.";
      }
    }

    bgImageInput.addEventListener("change", (event) => {
      const file = event.target.files && event.target.files[0];
      if (!file) {
        sourceImage = null;
        selection = null;
        drawSourceCanvas();
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          sourceImage = img;
          selection = null;
          drawSourceCanvas();
          statusEl.textContent = "배경 이미지가 로드되었습니다.";
        };
        img.onerror = () => {
          sourceImage = null;
          selection = null;
          drawSourceCanvas();
          statusEl.textContent = "이미지를 불러오는 중 오류가 발생했습니다.";
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    function getCanvasCoords(evt, canvasEl) {
      const rect = canvasEl.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      return { x, y };
    }

    sourceCanvas.addEventListener("mousedown", (evt) => {
      if (!sourceImage) return;
      isSelecting = true;
      const pos = getCanvasCoords(evt, sourceCanvas);
      selStartX = pos.x;
      selStartY = pos.y;
      selection = { x: selStartX, y: selStartY, w: 0, h: 0 };
      drawSourceCanvas();
    });

    sourceCanvas.addEventListener("mousemove", (evt) => {
      if (!isSelecting || !sourceImage) return;
      const pos = getCanvasCoords(evt, sourceCanvas);
      const x = Math.min(selStartX, pos.x);
      const y = Math.min(selStartY, pos.y);
      const w = Math.abs(pos.x - selStartX);
      const h = Math.abs(pos.y - selStartY);
      selection = { x, y, w, h };
      drawSourceCanvas();
    });

    function stopSelecting() {
      if (!isSelecting) return;
      isSelecting = false;
      if (selection && (selection.w < 5 || selection.h < 5)) {
        selection = null;
      }
      drawSourceCanvas();
    }

    sourceCanvas.addEventListener("mouseup", stopSelecting);
    sourceCanvas.addEventListener("mouseleave", stopSelecting);

    form.addEventListener("submit", async (event) => {
      event.preventDefault();

      let text = promptInput.value;
      if (!text || text.trim().length === 0) {
        statusEl.textContent = "텍스트를 입력해 주세요.";
        return;
      }

      const widthInput = document.getElementById("width");
      const heightInput = document.getElementById("height");

      let width = parseInt(widthInput.value, 10);
      let height = parseInt(heightInput.value, 10);

      if (!Number.isFinite(width) || width < 64) width = 64;
      if (!Number.isFinite(height) || height < 64) height = 64;
      if (width > 2048) width = 2048;
      if (height > 2048) height = 2048;

      widthInput.value = width;
      heightInput.value = height;

      statusEl.textContent = "배경과 텍스트를 그리는 중입니다.";
      generateBtn.disabled = true;

      try {
        canvas.width = width;
        canvas.height = height;

        if (sourceImage) {
          let sx = 0;
          let sy = 0;
          let sw = sourceImage.naturalWidth;
          let sh = sourceImage.naturalHeight;

          if (selection) {
            sx = Math.round(selection.x / sourceScale);
            sy = Math.round(selection.y / sourceScale);
            sw = Math.round(selection.w / sourceScale);
            sh = Math.round(selection.h / sourceScale);
            if (sw < 5 || sh < 5) {
              sx = 0;
              sy = 0;
              sw = sourceImage.naturalWidth;
              sh = sourceImage.naturalHeight;
            }
          }

          ctx.drawImage(sourceImage, sx, sy, sw, sh, 0, 0, width, height);
        } else {
          drawRandomBackground(ctx, width, height);
        }

        const styles = getCharStyles(text);
        drawTextCharacters(ctx, width, height, text, styles);

        const useLine = lineEnabledCheckbox.checked;
        const useRect = rectEnabledCheckbox.checked;
        const useCircle = circleEnabledCheckbox.checked;

        if (useLine || useRect || useCircle) {
          drawAntiMacroPattern(ctx, width, height);
        }

        const previewDataUrl = canvas.toDataURL("image/png");
        preview.src = previewDataUrl;

        let bmpBlob;
        try {
          bmpBlob = canvasToBMPBlob(canvas);
        } catch (err) {
          console.error("BMP 변환 중 오류:", err);
          statusEl.textContent = "BMP 변환 과정에서 오류가 발생했습니다.";
          generateBtn.disabled = false;
          return;
        }

        const bmpUrl = URL.createObjectURL(bmpBlob);
        downloadLink.href = bmpUrl;
        downloadLink.download = `text-image-${width}x${height}.bmp`;

        result.classList.remove("hidden");
        statusEl.textContent = "이미지가 생성되었습니다. BMP로 저장할 수 있습니다.";
      } catch (error) {
        console.error(error);
        statusEl.textContent = "이미지를 생성하는 중 오류가 발생했습니다.";
      } finally {
        generateBtn.disabled = false;
      }
    });

    // 초기 상태
    updateFontControls("");
  </script>
</body>
</html>

